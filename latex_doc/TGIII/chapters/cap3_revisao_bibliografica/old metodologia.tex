
\chapter{Metodologia}

Para a execução deste projeto, optou-se pelo uso de componentes amplamente disponíveis no mercado a relativamente baixo
custo, bem como software disponível gratuitamente no site do fabricante. Essas escolhas visam facilitar a
reproducibilidade do projeto, bem como tornar o resultado final do projeto mais eficiente, produzindo o resultado
desejado com o menor custo. 

Um outro fator relevante que impactou a escolha dos componentes a serem utilizados no projeto é a compatibilidade entre
eles - seja ela mecânica, eletrônica ou mesmo de software. Diferentemente de uma solução completa oferecida por
um só fabricante, em que há garantia de operação harmoniosa entre os componentes, este trabalho envolveu a composição de
diferentes partes, pelo que se tornou necessário avaliar a viabilidade de se utilizar todas elas em conjunto.

Ainda assim, dada a necessidade de se utilizar peças com formatos e dimensões específicas para a aplicação em questão,
optou-se também pelo uso de técnicas de impressão 3D. Essa decisão é compatível com o objetivo geral de baixos custos, e
também resolve problemas relacionados à montagem mecânica.


\section{Hardware}
A aquisição dos componentes de hardware empregados neste projeto se deu, em boa parte, por meio de lojas importadoras de
componentes. Optou-se por componentes de baixo custo e, ao mesmo tempo, comumente utilizados em projetos dessa natureza,
a fim de se ter amplo apoio da comunidade na resolução de eventuais problemas encontrados no desenvolvimento da solução.
A tabela \ref{custos} apresenta os custos de cada componente de hardware adquirido para uso exclusivo neste projeto
(excluindo, portanto, equipamentos empregados mas não utilizados apenas nele, como a impressora 3D).


\begin{quadro}[htb]
	\caption{Lista de componentes, materiais e seus custos - valores em reais (R\$) \label{custos}}
	 \begin{tabular}{|c|c|c|c|}
		\hline
		\textbf{Componente ou Material} & \textbf{Valor unitário} & \textbf{Quant} & \textbf{Valor Total} \\ \hline
		Driver Ponte H L298N \cite{l298n_produto} &  22,90 & 3 &  68,70   \\ \hline
		Motor DC 6V 210 RPM \cite{motor_dc_6v_produto} &  90,00 & 3 &  270,00   \\ \hline
		Filamento PLA \cite{filamento_pla_produto} &  99,99 & 1 &  99,99   \\ \hline
		Kit 4 rodas Omnidirecional \cite{omin_wheel_produto} &  131,35 & 1 &  131,35   \\ \hline
		Kit 4 peças eixo roda \cite{omin_wheel_produto} &  42,15 & 1 &  42,15   \\ \hline
		STM32 (microcontrolador) \cite{stm32_produto} &  46,90 & 1 &  46,90   \\ \hline
		Bateria selada 6V \cite{bateria_6v_produto} &  69,90 & 1 &  69,90  \\ \hline
		Powerbank &  119,90 & 1 &  119,90   \\ \hline
		Paquímetro  &  49,90 & 1 &  49,90   \\ \hline
		Ferro de solda &  43,20 & 1 &  43,20   \\ \hline
		Solda &  12,99 & 1 &  12,99   \\ \hline
		Conector mjjst macho &  4,90 & 3 &  14,70   \\ \hline
		Conector mjjst femea &  4,90 & 3 &  14,70   \\ \hline
		Garra jacaré &  1,65 & 2 &  3,30   \\ \hline
		Driver Ponte H DTV8833 \cite{drv8833_produto} &  15,00 & 3 &  45,00   \\ \hline
		Módulo Bluetooth \cite{hc05_produto} &  35,00 & 1 &  35,00   \\ \hline
		Mini Protoboard &  5,00 & 2 &  10,00   \\ \hline
		Protoboard 830 &  16,00 & 1 &  16,00   \\ \hline
		Jumper macho-macho &  8,00 & 1 &  8,00   \\ \hline
		Pasta de solda &  14,99 & 1 &  14,99   \\ \hline
		Sugador de solda &  12,99 & 1 &  12,99   \\ \hline	
		\textbf{CUSTO TOTAL} & & & \textbf{ 1.129,66}   \\ \hline
	\end{tabular}
\end{quadro}

\subsection{Componentes eletrônicos}

\subsubsection{Motor de passo}

Para a execução deste projeto, foi pensado inicialmente o uso de motores DC,  devido a facilidade de uso.
Como os motores DC variam a velocidade com base na tensão disponível, tornando o acionamento simples.
Porém o controle de velocidade é mais complexo, fazendo o uso de encoders.
A leitura dos resultados do encoders possuem muitos ruidos de medição e variam muito com a frequência de amostragem, 
mas remover os ruidos de alta frequência do sinal possa ser resolvido usando um algorítimo de filtro passa baixa discreto.
Porém os motores DC tem a limitação de trabalharem em uma faixa de rpm específica, podendo o motor não alcançar um rpm mínimo desejado.
Um motor de 6v/210 RPM usado tinha baixo torque a baixas velocidades, além de precisar de uma corrente de partida mais alta do que a tensão inicial fornecia.
Trocar por motores de menor velocidade acabaria tendo o problema de não ser possível alçarem um velocidade mais alta quando necessário.
Para usar um motor DC com uma boa variação de velocidade, seria necessário usar um conjunto de engrenagens para obter o rpm desejado sem grandes perdas de torque nos motores
e sem problemas de corrente de partida insuficiente.

Devido essas limitações se optou por motores de passo,  nema 17 bipolar, de uso padrão em impressoras 3D.
A escolha foi motivada pela facilidade de aquisição e maior disponibilidade no mercado, tornando o preço mais baixo do que motores DC,
Em média os valores de um Nema 17 chegam a metade do valor de um motor DC de baixo RPM.
Outro motivo que levou a escolha, foi o fato de serem motores de reposição de uma impressora 3D usada no projeto.

Pelo fato de motor de passo ser controlado em passos por segundo, o controle de velocidade é mais fácil,
e as possíveis variações de rpm ocorrem a nível de ciclos do microcontrolador.

Porém motores de passo exigem um cuidado maior, além de exigem uma alimentação maior, de 12v a 24v, os uso dos drivers para motor de passo exigem um maior cuidado na montagem.

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.7\textwidth]{figures/JK42HS40_1704_13A}
	\caption{Motor de passo Nema 17 \cite{motor_dc_6v_encoder}}
\end{figure}

\begin{quadro}[htb]
\caption{\label{Especificacoes_motordc_6v}Especificações do motor DC 6V}
	 \begin{tabular}{|c|c|c|c|}
		\hline
		\textbf{Especificação} & \textbf{Valor} \\ \hline
		Corrente por fase & 1.7A  \\ \hline
		Torque nomimal  & 4.2 KGF (~46 N) \\ \hline
		Angulo de passo & 1.8° \\ \hline
		Polaridade & bipolar \\ \hline
	\end{tabular}
	\fonte{\cite{chinhai_motor}}
\end{quadro}


Outro desafio do motor de passo é idenfiticar as fases, pois cada fabricante pode ter uma ordem diferente dos pinos de saida do motor.
Para idenfiticar quais pinos compõem cada fase, bastou verificar com o multimetro quais fases estavam em curto.
Restando identicar somente o pontos A e B de cada fase de acordo com o diagrama a seguir.

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.7\textwidth]{figures/motor_wiring}
	\caption{Motor de passo - Fases Bipolar \cite{motor_dc_6v_encoder}}
\end{figure}

Para identificar quais eram os pontos A e B de cada fase, foi necessário um processo de tentantiva e erro,
para relacionar o diagrama de fases com os pinos do motor, e o resultado esta ilustrado na figura \ref{nema_pinout}

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.7\textwidth]{figures/motor_pinout}
	\caption{Motor de passo - Idetificação dos pinos  \cite{motor_dc_6v_encoder}}
	\label{nema_pinout}
\end{figure}



\subsubsection{Driver de Motor}

Diferente de um driver de motor DC, como o L289N e o DRV8833, que rececem um sinal PWM e convertem propocionalmente
para o sinal de tensão a ser aplicado no motor,  os driver de motor de passo são responsáveis por aplicar uma corrente constante, independende da tensão de alimentação.
sendo essa podendo variar de acordo com os limites dos motores e do próprio driver,  por convensão, para um Nema 17, é comnum se trabalhar com uma alimentação
de 12v a 24v.

O driver DRV8825 exige alguns cuidados, alguns informados em documentação e outros não.
Um dos cuidado a ser informado é o ajuste do Vref, nas documentações é dito que é necessário apenas ligar a alimentação dos motores e o ground do microcontrolador
porém em vários testes, alguns drivers pararam de funcionar,  foi então encontrado em fóruns que é recomendado que a carga (o motor) esteja ligado durante esse processo de ajuste do Vref
e que e nenhuma hipotese o driver deve ser alimentado sem que a carga esteja conectada.


\begin{figure}[htb]
	\centering
	\includegraphics[width=0.7\textwidth]{figures/DRV8825}
	\caption{Driver Ponte H DVR8833 \cite{DRV8833_image}}
\end{figure}


\subsubsection{Microcontrolador}


Inicialmente foi escolhido o STM32F103C8, porém a comunicação serial via micro-USB-B não pode ser usada ao mesmo tempo que
a alimentação de 3.3v do gravador ST-link. isso pode causar danos no controlador. 


Por causa dessa limitação foi escolhido o ESP32 DevKit v1.
Embora  quantidade de pinos disponíveis seja menor, não será necessário o uso de pinos de comunicação serial para usar com um módulo bluetooth,
já que o ESP32 já possui bluetooth integrado.

De acordo com o datasheet do ESP32 \cite{esp32_datasheet} e a análises disponíveis online de entusiastas do uso do ESP32 \cite{esp32_reference},
existem alguns pinos recomendados para se usar, alguns que requerem atenção no uso, e outros que recomendam evitar.

\begin{figure}[htb]
	\centering
	\includegraphics[width=1.0\textwidth]{figures/esp32_pinout}
	\caption{Diagrama de pinos do ESP32 Devkit v1 \cite{esp32_reference}}
\end{figure}


\begin{figure}[htb]
	\centering
	\includegraphics[width=0.35\textwidth]{figures/esp32_pinout_ref}
	\caption{Recomendação de uso dos pinos do ESP32 Devkit v1 \cite{esp32_reference}}
\end{figure}






\subsubsection{Alimentação - ESP32}

Para alimentação do ESP32, pode usar tanto uma bateria de 5v ou 3.3v, pois possui dois pinos para alimentação: 

\subsubsubsection{Pino de 5v não regulado}

Fontes divergem em relação à tensão máxima (\cite{esp32_reference_power_supply_1}, \cite{esp32_reference_power_supply_2}),
que pode ser usada, porém, a maioria concorda em manter de 6v a 7v.

\subsubsubsection{Pino de 3.3v regulado}
Esse pino pode receber no máximo 3.3v, podendo funcionar entre 3.1v e 3.3v sem problema.

\subsubsubsection{micro USB}
Essa opção permite usar um powerbank, porém o conector do ESP32 é um Micro-USB B, modelo que usa protocolo USB 2.0, que pode fornece apenas a 500mA a 5v \cite{micro_usb_b}.
500mA É suficiente para alimentar o ESP32, que pode consumir até 260mA \cite{esp_max_current}.
Porem um powerbank pode ser uma solução muito ineficiente do ponto de vista energético, os modelos populares possuem baterias de lítio de 3.7v, que é convertido para 5v,
e posteriormente dentro do ESP32 a tensão é convertida novamente para 3.3v. Apenas no modelo PN-952 da CNHPineng sai de 5000mAh a 3.7v  para 3160mAh a 5v,
podendo novamente perder mais corrente por hora ao ser convertido para 3.3v no ESP32

\subsubsection{Motores de passo}

Os motores de passo NEMA 17 podem ser alimentados, através do driver, com 12v a 24v.
Observando a possibilidade de uma bateria de 12v/24v ficar sem uso depois do projeto,
e considerando que ferramentas elétricas possuem baterias padronizadas de 12v/18v/36V, foi considerando utilizar 3 baterias de 12v da bosch, que já estavam disponíveis para uso.
Cada bateria tem tensão nominal de 12v a 2Ah, do modelo GBA, que são usadas em aspirador de pó, esmerilhadeiras, furadeiras, plainas e serras circulares.


% https://www.bosch-professional.com/br/pt/products/gba-12v-max-2-0ah-1600A0021D
% https://www.bosch-professional.com/br/pt/products/gas-12v-06019E3000
% https://www.bosch-professional.com/br/pt/products/gwg-12v-50-s-06013A70E0


\subsection{Fabricação e montagem}
O chassi e demais peças foram fabricados por meio de impressão 3D, usando filamento de PLA (ácido poliáctico). As
peças foram projetadas no AutoCAD, e posteriormente modeladas em 3D com o SolidWorks. A geometria do modelo
resultante de cada peça foi convertida em código G para uma impressora 3D por meio do software UltiMaker Cuda. Por
fim, a impressão das peças foi realizada em uma impressora Ender 3 S1 Pro.



% \subsection{Joystick de controle}
% Um joystick de 3 eixos para controlar o robô para testar a cinemática de movimento.
% {\color{red} É necessário aqui especificar o modelo utilizado e descrever características.}

% \subsection{Sensores}
% {\color{red} Esta subseção deve descrever os sensores utilizados e também sua finalidade.}

% \subsection{Dispositivos de comunicação}
% {\color{red} Esta subseção deve descrever os dispositivos de comunicação utilizados (Wi-fi, Bluetooth, etc) e também sua
% finalidade.}

% \subsection{Calibração de parâmetros}
% {\color{red} Caso haja necessidade de calibração de parâmetros de alguns dos componentes utilizados (sensibilidade de
% sensores, histerese de componentes mecânicos, taxa de comunicação de dispositivos, etc), os procedimentos devem ser
% descritos nesta subseção.}

\section{Software}
Para controlar o robô, inicialmente foi pensando em usar uma aplicação drag\&drop para criar um app andriod que envia dados via bluetooth serial.
Porem realizando um benchmark de outros app disponíveis para interações bluetooth com arduino optamos por usar dois desses app e usar de uma maneira diferente.


\subsection{Programação do microcontrolador}

Nesta aplicação, o microcontrolador contém é responsável por coordenar a operação do robô. Por essa razão, foi
necessário programar tal funcionalidade em sua memória. Neste processo, foi necessário configurar os diferentes pinos de
entrada segundo suas capacidades e o uso desejado no projeto, bem como implementar o processamento dos sinais de entrada
(referentes à velocidade dos motores) e a produção de saída (valores a serem enviados como variável manipulada para os
motores do robô). É também do microcontrolador a tarefa de interpretar os comandos recebidos via Bluetooth do próprio microcontrolador
e convertê-los em sinal de controle.

\subsection{Aplicativo Android}

O aplicativo Arduino Bluetooth Controller possui uma opção em que o aplicativo envia uma 'string' representando as cores RGB em 'int8'.
por exemplo,  vermelho seria '255000000' (r=255, g=0, b=0). E a interface é o modelo de cor HSV em 2 dimensões de ponta cabeça,
figura \ref{arduino_bluetooth_controller_hsl_model}.


\begin{figure}[htb]
	\centering
	\includegraphics[width=0.40\textwidth]{figures/andriod_bluetooth_controller_hsl_model}
	\caption{Tela de controle RGB do aplicativo Arduino Bluetooth Controller}
	\label{arduino_bluetooth_controller_hsl_model}
\end{figure}

No modelo HSV,  figura  \ref{rbg_hsl_hsv}, 'H' significa "hue" ou matiz, e é um valor do angulo no modelo HSV, 'S' significa 'saturação' e corresponde a um valor de raio,
por último, 'V' é valor, que corresponde a uma terceira dimensão, que não aparece no modelo bidimensional disponível no aplicativo.
Exitem outros dois modelos parecidos que usam a mesma representação cilíndrica, HSL, e HSB, que possuem uma lógica semelhando ao HSV.


\begin{figure}[htb]
	\centering
	\includegraphics[width=0.6\textwidth]{figures/RBG_HSL_HSV}
	\caption{Modelos RGB, HSL e HSV \cite{rbg_hsl_hsv}}
	\label{rbg_hsl_hsv}
\end{figure}

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/HSV}
	\caption{Modelo HSV bidimensional \cite{hsv_model}}
\end{figure}


O aplicativo retorna os valores em RGB, então usando um algorítimo que converte RGB para HSV e invertendo o eixo Y
é possível ter os valores de angulo e módulo de um vetor velocidade.
As imagens \ref{hsv_exemplo_1} e \ref{hsv_exemplo_2} possuem os seguintes valores de RGB, que aplicados no algorítimo de conversão geram os resultados no quadro \ref{HSV_resultado}
Facilmente podemos extrair informações de direção e magniture que podem ser usados para controlar o robô.

\begin{figure}[htb]
	\centering
	\includegraphics[width=1.0\textwidth]{figures/example_1_arduino_color}
	\caption{Modelo HSV bidimensional exemplos n1}
	\label{hsv_exemplo_1}
\end{figure}

\begin{figure}[htb]
	\centering
	\includegraphics[width=1.0\textwidth]{figures/example_2_arduino_color}
	\caption{Modelo HSV bidimensional exemplos n2}
	\label{hsv_exemplo_2}
\end{figure}

\begin{quadro}[htb]
	\caption{\label{HSV_resultado}Resultado algoritmo}
		 \begin{tabular}{|c|c|c|}
			\hline
			\textbf{RGB} & \textbf{Ângulo} & \textbf{Magniture} \\ \hline
			196, 115, 255 & 275,0 & 54,9\% \\ \hline
			131, 143, 255 & 234,0 & 48,63\% \\ \hline
			123, 255, 245 & 175,0 & 51,76\% \\ \hline
			105, 255, 159 & 142,0 & 58,82\% \\ \hline
			198, 255, 124 & 86,0 & 51,37\% \\ \hline
			255, 251, 115 & 58,0 & 54,9\% \\ \hline
			255, 101, 107 & 358,0 & 60,39\% \\ \hline
			255, 142, 247 & 304,0 & 44,31\% \\ \hline
			001, 000, 255 & 240,0 & 100,0\% \\ \hline
			000, 255, 242 & 177,0 & 100,0\% \\ \hline
			000, 255, 023 & 125,0 & 100,0\% \\ \hline
			130, 255, 000 & 89,0 & 100,0\% \\ \hline
			255, 244, 000 & 57,0 & 100,0\% \\ \hline
			255, 000, 005 & 359,0 & 100,0\% \\ \hline
			254, 000, 255 & 300,0 & 100,0\% \\ \hline
		\end{tabular}
	\end{quadro}



	\subsection{Montagem da parte elétrica}

	Os componentes foram ligados usando cabos do tipo jumper e protoboard para encaixar o microcontrolador e os drivers,
	essa ligação foi útil para realizar os testes, porém o uso cabos do tipo jumper e protoboard podem oferecer mau contado, causando falhas no funcionamento do robô.
	Para realizar testes finais, realizar junção dos cabos, e soldar os cabos a conectores JST devem resolver o problema de mau contado.
	
	
	\subsubsection{Ligação dos componentes}
	Cada motor precisa de 2 sinais de PWM, então foi necessário usar 6 pinos de PWM do STM32, as duplas de pinos que suportam PWM foram $P_{B6}$ - $P_{B7}$, $P_{B8}$ - $P_{B9}$ e $P_{A9}$ - $P_{A10}$, respectivamente para os motores 1, 2 e 3
	E para cada encorder de motor, foi necessário mais 6 pinos, 2 pinos para cada fase dos 3 encoders, $P_{B0}$ - $P_{B1}$, $P_{A6}$ - $P_{B7}$ e $P_{B10}$ - $P_{B11}$, também respectivamente para os motores 1, 2 e 3, sendo os  $P_{B1}$, $P_{B7}$ e $P_{B11}$ definidos para a Fase A do encoder
	A alimentação dos encoders será feito pelo pino de 3.3v do STM32, e o GND também vindo do microcontrolador.
	O Módulo bluetooth HC-05 terá alimentação sendo fornecida pelo pino de 5v do microtrolador (GND sendo o mesmo usado para os encoders).
	Já a comunicação serial será feita conectando o TXD do módulo com o pino $P_{A3}$, que é o pino RX2 (RX da $USART\_2$), e o RXD do módulo conectado ao $P_{A2}$, pino TX2 (TX da $USART\_2$).
	Embora o HC-05 trabalhe com UART, o protocolo USART é compatível com UART, podendo usar os pinos de uma USART como se fossem uma UART.
	
	Os pinos de PWM são conectados nos drivers DVR8833, com  $P_{B6}$, $P_{B8}$ e $P_{A9}$ como inputs nos pinos $IN1$ de cada driver, e os demais pinos conectados aos pinos $IN2$.
	A alimentação dos drivers é feita por uma fonte de 6v, e os pinos $OUT1$ e $OUT2$ dos drivers conectados respectivamente as entradas $M1$ e $M2$ dos motores. A figura \ref{fig:diagrama_montagem} contém o diagrama com as ligações descritas.
	
	\begin{figure}[htb]
		\centering
		\includegraphics[width=1.0\textwidth]{figures/diagrama_montagem}
		\caption{Diagrama de montagem dos componentes}
		\label{fig:diagrama_montagem}
	\end{figure}
	
	
	\subsubsection{Modelagem e fabricação da estrutura}
	
	O desenvolvimento das peças usadas na estrutura do robô foram feitas usando AutoCAD, o chassi principal que possui a geometria circular do robô foi desenhado com base nas medidas finais do robô,
	com foco no raio até o centro das rodas, o raio planejado é de 100mm. Os mancais foram planejados com base nas dimensões dos motores. 
	
	As figuras relacionadas ao CAD, podem ser encontradas no anexo \ref{att_fabricao_montagem_cad}, quanto a modelagem,
	anexo \ref{att_fabricao_montagem_modelagem}, e impressão 3D e montagem, anexo \ref{att_fabricao_montagem_impressao}.
	
	
	
	\subsection{Controle de velocidade}
	
	\subsubsection{Medição de velicidade do motor}
	
	Como encoder possuí dois sinais de onda quadadra defasadas em 90º, fase A e fase B, cujos vales e picos são valores lógicos HIGH e LOW, 
	e direção de rotação do motor pode ser definida pela diferença entre as fases, se fase A esta adiantada ou atrasada em relação a fase B
	É possível calcular a velocidade com base nas subidas da onda quadrada de uma fase, e o valor logico da outra fase no momento da subida.
	Por exemplo,  observando a fase B, toda vez em que há uma subida, se o valor da fase A for alto, então incrementar +1 em um contador, se a fase A tiver valor baixo, então incrementar -1 no contador.
	Quando o valor da fase A for alto, então o motor esta rodando em um sentido,  quando o valor  for baixo, então o motor esta rodando no sentido contrário.
	Medindo o valor do contador por um $\Delta_{T}$, se resulta na quantidade de pulsos por segundo.
	Para converter de pulsos por segundo para RPM, basta dividir pela resolução do motor+encoder,  que é de 1:34 do motor, e 11 pulsos por rotação do encoder, o que resulta em 374,
	e multiplicar por 60 para ter o resultado em rotações por minuto.
	
	\begin{tikzpicture}[node distance=2cm]
	
		\node (start) [startstop] {início loop};
		\node (pro1) [process, below of=start] {ENQUANTO DELTA T};
		
		\node (in1) [io, right of=pro1, xshift= 4cm] {QUANDO FASE B = SUBIDA};
		
		\node (dec1) [decision, below of=in1, yshift=-2cm] {SE FASE A = 1};
		\node (pro1a) [process, below of=dec1, yshift= -2cm] {INCREMENTAR CONTADOR em +1};
		\node (pro1b) [process, right of=dec1, xshift= 3cm] {INCREMENTAR CONTADOR em -1};
		
		
		\node (count) [process, below of=pro1, yshift= -9cm] {CONTADOR DIVIDO POR DELTA T};
		
		\draw [arrow] (start) -- (pro1);
		\draw [arrow] (pro1) -- node[anchor=north] {sim} (in1);
		\draw [arrow] (in1) -- (dec1);
		\draw [arrow] (dec1) -- node[anchor=east] {sim} (pro1a);
		\draw [arrow] (dec1) -- node[anchor=north] {não} (pro1b);
		
		\draw [arrow] (pro1) -- node[anchor=east] {não} (count);
	
	\end{tikzpicture}
	
	
	
	Na implementação dessa lógica no STM32, o desafio foi a definição do $\Delta_{T}$,
	Se o $\Delta_{T}$ for muito pequeno, o resultados de pulsos por segundo pode tender ao infinito, gerando valores muito altos.
	Na figura \ref{fig:medidas_altas} em laranja, esta o resultado do rpm considerando o $\Delta_{T}$ como o tempo entre os ciclos do micrcontrolador.
	A outra opção, foi definir um $\Delta_{T}$ fixo, definindo uma frequencia de medição pré definida, e o resultado pode ser visto em azul na figura \ref{fig:medidas_altas}
	Essa outra opção de $\Delta_{T}$ resultou em um sinal que tem uma componente em alta frequência com uma amplitude até consideral.
	Analisando os dois sinais no dominio da frequêcia na figura \ref{fig:frequencia_medidas_altas}, o espectro em frequência do sinal em laranja possui amplitudes muitos semelhante em todo espectro, mas o espectro do sinal em azul, fica bem claro que em altas frequencias é composto mais por ruidos
	e as frequencia médias tem amplitude menor em relação as frequências baixas, o que torna mais fácil aplicar um filtro passa-baixa para reduzir as frenquências médias e altas.
	
	A figura \ref{fig:passa_baixa_teste}, mostra um dos teste de filtro passa baixa, em o sinal em laranja ainda persiste esses valores tentendo ao infinito, devido a ampliture eles se tornam um pouco dificil de serem retirados.
	Mas o sinal em azul acaba tendo um resultado melhor depois do filtro, muito semelhando ao sinal em laranja.
	Com base nesse resultado, foi decidido seguir com o método em que o $\Delta_{T}$ é definido por uma frequência pré definida.
	
	
	\begin{figure}[ht]
		\centering
		\includegraphics{figures/medidas_altas}
		\caption{Problemas com delta T muito pequeno}
		\label{fig:medidas_altas}
	\end{figure}
	
	\begin{figure}[ht]
		\centering
		\includegraphics{figures/frequencia_medidas_altas}
		\caption{Frequências}
		\label{fig:frequencia_medidas_altas}
	\end{figure}
	
	\begin{figure}[ht]
		\centering
		\includegraphics{figures/passa_baixa_teste}
		\caption{Passa baixa teste}
		\label{fig:passa_baixa_teste}
	\end{figure}
	
	
	Com o método definido, foi definido um $\Delta_{T}$ em 100hz eu um filtro passa baixa em 2hz
	As imagens no anexo \ref{att_medicao_motores}, mostra as imagens comparando o sinal original e o sinal filtrado para cada motor.
	A equação \ref{eqn:equacao_diferenca} a seguir é a equação de diferença do filtro, considerando uma amostragem de 100hz e frequência de corte em 2hz.
	
	\begin{equation}
		\begin{split}
			y[k] = 0.0591174 \cdot u \left[ k \right] +  0.0591174 \cdot u[k - 1] + 0.88176521 \cdot y[k - 1]
		\end{split}
		\label{eqn:equacao_diferenca}
	\end{equation}
	
	\subsubsection{Curva PWM x RPM - problema da não linearidade}
	
	Depois de definido como calcular a velocidade o próximo desafio foi lidar com a não linearidade entre o PWM e o resultado medido em RPM.
	Como pode ser visto na figura \ref{fig:grafico_pwm_x_rpm}, na comparação entre o valor do PWM e o RPM no tempo.
	
	\begin{figure}[htb]
		\centering
		\includegraphics{figures/pwm_x_rpm}
		\caption{Curva PWM e RPM no tempo}
		\label{fig:grafico_pwm_x_rpm}
	\end{figure}
	
	Considerando essa não linearidade, foram realizadas 15k medições em PWM vs RPM para definir uma equação que pudesse relacionar o PWM com o RPM.
	Como pode ser observado na figura  \ref{fig:medicao_pwm_x_rpm_dados_brutos}, os resultados possuem uma tendência, mas possuem alguns pontos fora da curta.
	devido ao esses ruídos nas medições ss dados foram tratatos para obter valores médios dos resultados usando python,
	o código pode ser visto no anexo \ref{att_limpeza_python}.
	
	\begin{figure}[htb]
		\centering
		\includegraphics{figures/curva_pwm_x_rpm_dados_brutos}
		\caption{Curva PWM x RPM dados brutos}
		\label{fig:medicao_pwm_x_rpm_dados_brutos}
	\end{figure}
	
	
	O resultado da limpeza dos dados pode ser vizualizado na figura \ref{fig:medicao_pwm_x_rpm_dados_medios}.
	Após a limpeza dos dados, os dados foram importados para o matlab, anexo \ref{att_matlab},
	para obter um polinômio que possa definir a curva, o polinômio resultante é a equação \ref{eqn:polimonio_rpm}, e a figura \ref{fig:curva_ajustada} representa a curva ajustada.
	A equação do polinômio foi inserida no código do micrcontrolador, foi testado definir um RPM de 150, e a tabela \ref{medicao_motores} trás uma amostra dos resultados dos RPMs de cada motor.
	Com essa equação é mais fácil definir um comportamento linear, facilitando a aplicação de um controle PDI.
	
	\begin{equation}
		\begin{split}
			0.0001131x^{4} + -0.03064x^{3} + 2.993x^{2} + -1.257x + 9017
		\end{split}
		\label{eqn:polimonio_rpm}
	\end{equation}
	
	\begin{figure}[htb]
		\centering
		\includegraphics{figures/curva_pwm_x_rpm_dados_medios}
		\caption{Curva PWM x RPM dados médios}
		\label{fig:medicao_pwm_x_rpm_dados_medios}
	\end{figure}
	
	\begin{figure}[htb]
		\centering
		\includegraphics{figures/curva_ajustada}
		\caption{Curva ajustada}
		\label{fig:curva_ajustada}
	\end{figure}
	
	
	
	\begin{quadro}[htb]
		\caption{\label{medicao_motores}Medição rpms motores}
		 \begin{tabular}{|c|c|c|c|c|}
			\hline
			\textbf{$Tempo_{seg}$} & \textbf{$RPM_{definido}$} & \textbf{$RPM_{real_{1}}$} & \textbf{$RPM_{real_{2}}$} & \textbf{$RPM_{real_{3}}$} \\ \hline
			52.954 & 150.00  & 141.03 & 162.69 & 149.82 \\ \hline
			52.954 & 150.00  & 141.43 & 162.43 & 149.18 \\ \hline
			53.000 & 150.00  & 140.83 & 162.19 & 148.61 \\ \hline
			53.000 & 150.00  & 140.30 & 161.98 & 149.06 \\ \hline
			53.000 & 150.00  & 140.79 & 161.80 & 149.46 \\ \hline
			53.000 & 150.00  & 141.21 & 161.64 & 148.86 \\ \hline
			53.046 & 150.00  & 141.59 & 161.49 & 149.28 \\ \hline
			53.046 & 150.00  & 141.92 & 161.37 & 149.65 \\ \hline
			53.046 & 150.00  & 141.26 & 161.25 & 149.02 \\ \hline
			53.046 & 150.00  & 140.68 & 162.11 & 148.48 \\ \hline
			53.046 & 150.00  & 141.12 & 162.86 & 148.94 \\ \hline
			53.092 & 150.00  & 141.51 & 162.57 & 149.35 \\ \hline
			53.092 & 150.00  & 141.85 & 162.32 & 148.76 \\ \hline
			53.092 & 150.00  & 141.20 & 162.09 & 149.19 \\ \hline
			53.092 & 150.00  & 140.63 & 161.90 & 149.57 \\ \hline
		\end{tabular}
	\end{quadro}
	
	
	\subsection{Aplicativo andriod - Envio de dados via bluetooth}
	
	
	\subsection{Implementação da medição de rpm e filtro passa baixa no microcontrolador}
	
	Para medir a velocidade de um motor DC com base no encoder, foi necessário realizar a leitura das subidas dos calores de LOW para HIGH de uma das fases do enconder, e comparar com outra Fase
	Para isso usamos o sistema de interrupção do microcontrolador.
	Exemplo do trecho de código que realiza a leitura dos valores do encoder, e registra em um contador a quantidade de pulsos de uma fase.
	
	
	\lstset{language=C}
	\begin{lstlisting}
	
	long prevTime = 0;
	long currTime = micros();
	
	volatile int pos_i_1 = 0;
	
	int prevPosition_1 = 0;
	
	
	void setup() {
	
		motorsSetupPins();
		encodersSetupPins();
	
		attachInterrupt(digitalPinToInterrupt(PB0), readEncoder1, RISING);
		
	}
	
	void loop() {
	
			int currPosition_1 = 0;
	
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
				currPosition_1 = pos_i_1;
			};
			
			prevPosition_1 = currPosition_1;
	}
	
	void readEncoder1(){ 
		int b = digitalRead(PB1);
		if(b>0){
			pos_i_1++;
		}
		else {
			pos_i_1--;
		}
	}
	
	\end{lstlisting}
	
	
	Após obtendo os a quantidade de pulsos é possivel calcular a taxa de pulsos por segundo, usando o diferencial da velocidade no dominio discreto, $\Delta$p/$\Delta$t.
	
	\lstset{language=C}
	\begin{lstlisting}
	
	#define HALL_RESOLUTION 374
	
	long prevTime = 0;
	long currTime = micros();
	
	volatile int pos_i_1 = 0;
	
	int prevPosition_1 = 0;
	
	
	float direction_angle = 90;
	void setup() {
	
		motorsSetupPins();
		encodersSetupPins();
	
		attachInterrupt(digitalPinToInterrupt(PB0), readEncoder1, RISING);
		
	}
	
	void loop() {
	
		currTime = micros();
	
		int currPosition_1 = 0;
	
	
		ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
			currPosition_1 = pos_i_1;
		};
		
		float rpm1 = calc_rpm(currTime, prevTime, currPosition_1, prevPosition_1);
	
		prevPosition_1 = currPosition_1;
		prevPosition_3 = currPosition_3;
	
		prevTime = currTime;  
	
	}
	
	void readEncoder1(){ 
		int b = digitalRead(PB1);
		if(b>0){
			pos_i_1++;
		}
		else {
			pos_i_1--;
		}
	}
	
	
	float calc_rpm(long currT, long prevT, int pos, int posPrev){
	
		float deltaT = ((float) (currT-prevT))/1.0e6;
		float pulse_per_seconds = (pos - posPrev)/deltaT;
		float rpm = 60*pulse_per_seconds/HALL_RESOLUTION;
	
		return rpm;
	}
	
	\end{lstlisting}
	
	
	Porém calcular velocidade a cada ciclo do micrcontrolador acaba registrando valores de tempo muito pequenos, fazendo a velocidade tender ao infinito
	A solução foi estabelecer uma amostragem do registro da velocidade, porem a amostragem adiciona um ruido com frequências maiories que do sinal original e de amplitude definida.
	Para retirar essas frequência do sinal, o filtro passa baixa foi implementado no código.
	
	
	\lstset{language=C}
	\begin{lstlisting}
	
	#define HALL_RESOLUTION 374
	#define DT_TIME_SAMPLE_RATE_ENCODER 10 // encoder position reading update rate
	
	int nextChangeSampleRate  = (millis() + DT_TIME_SAMPLE_RATE_ENCODER);
	
	long prevTime = 0;
	long currTime = micros();
	
	volatile int pos_i_1 = 0;
	
	int prevPosition_1 = 0;
	
	float filterRpm_1 = 0;
	
	float prevRpm_1 = 0;
	
	
	void setup() {
	
		encodersSetupPins();
	
		attachInterrupt(digitalPinToInterrupt(PB0), readEncoder1, RISING);
		
	}
	
	void loop() {
	
		//Leitura da velocidade
		if (millis()>=nextChangeSampleRate){
	
			currTime = micros();
	
			int currPosition_1 = 0;
	
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
				currPosition_1 = pos_i_1;
			};
			
			float rpm1 = calc_rpm(currTime, prevTime, currPosition_1, prevPosition_1);
	
			filterRpm_1 = low_pass_filter_first_order(rpm1, prevRpm_1, filterRpm_1);
	
			prevPosition_1 = currPosition_1;
	
			prevRpm_1 = rpm1;
	
			prevTime = currTime;
	
			nextChangeSampleRate = millis() + DT_TIME_SAMPLE_RATE_ENCODER;
		}
		
	}
	
	void readEncoder1(){ 
		int b = digitalRead(PB1);
		if(b>0){
			pos_i_1++;
		}
		else {
			pos_i_1--;
		}
	}
	
	float calc_rpm(long currT, long prevT, int pos, int posPrev){
	
		float deltaT = ((float) (currT-prevT))/1.0e6;
		float pulse_per_seconds = (pos - posPrev)/deltaT;
		float rpm = 60*pulse_per_seconds/HALL_RESOLUTION;
	
		return rpm;
	}
	
	
	
	float low_pass_filter_first_order(float currRpm, float prevRpm, float prevFilterRpm){
	
		float posFilterRpm = 0.881765*prevFilterRpm + 0.0591174*currRpm + 0.0591174*prevRpm;
	
		return posFilterRpm;
	}
	
	\end{lstlisting}