

\chapter{Medição de rpm e aplicação de filtro passa baixa em código C \label{anx_passa_baixa}}

\lstset{language=C}
\begin{lstlisting}
#include <util/atomic.h>
#include <Arduino.h>
#define HALL_RESOLUTION 374
#define DT_SAMPLE_RATE_ENCODER 10 // encoder position reading update rate
int nextChSampleRate  = (millis() + DT_SAMPLE_RATE_ENCODER);
long prevTime = 0, currTime = micros();
volatile int pos_i_1 = 0;
int prevPos_1 = 0;
float filterRpm_1 = 0, prevRpm_1 = 0;
void setup() {
    encodersSetupPins();
    attachInterrupt(digitalPinToInterrupt(PB0), readEncoder1, RISING);   
}
void loop() {
    if (millis()>=nextChSampleRate){
        currTime = micros();
        int currPos_1 = 0;
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE){currPos_1 = pos_i_1;};
        float rpm1 = calc_rpm(currTime, prevTime, currPos_1, prevPos_1);
        filterRpm_1 = lowpassFilter1thOrder(rpm1, prevRpm_1, filterRpm_1);
        prevPos_1 = currPos_1; prevRpm_1 = rpm1; prevTime = currTime;
        nextChSampleRate = millis() + DT_SAMPLE_RATE_ENCODER;
    }
}
void readEncoder1(){ 
    int b = digitalRead(PB1);
    if(b>0){pos_i_1++;}
    else {pos_i_1--;}
}
float calc_rpm(long currT, long prevT, int pos, int posPrev){
    float deltaT = ((float) (currT-prevT))/1.0e6;
    float pulse_per_seconds = (pos - posPrev)/deltaT;
    float rpm = 60*pulse_per_seconds/HALL_RESOLUTION;
    return rpm;
}
float lowpassFilter1thOrder(float currRpm, float prevRpm, float prevFilterRpm){
    float posFilterRpm = 0.881765*prevFilterRpm\
	 + 0.0591174*currRpm + 0.0591174*prevRpm;
    return posFilterRpm;
}
\end{lstlisting}